import * as esbuild from "esbuild"
import { writeFile, realpathSync } from "node:fs"
import { resolve as resolvePath, relative as relativePath } from "node:path"

const cwd = process.cwd()
const [, , wwwRoot, ...entryPoints] = process.argv

if (!wwwRoot.length || wwwRoot.endsWith("/") || !entryPoints.length) {
  throw new Error("Invalid wwwRoot or entryPoints")
}

const outbase = "assets"
const outdir = relativePath(cwd, resolvePath(realpathSync(wwwRoot), outbase))
const isProduction = process.env.NODE_ENV === "production"

const publicPath = "/static/assets/"
const context = await esbuild.context({
  entryPoints,
  outdir,
  outbase,
  entryNames: isProduction ? "[dir]/[name]-[hash]" : undefined,
  format: "esm",
  publicPath,
  bundle: true,
  minify: true,
  sourcemap: isProduction ? false : "inline",
  splitting: true,
  treeShaking: true,
  metafile: true,
  platform: "browser",
  target: ["safari13", "firefox68"],
  loader: {
    ".png": "file",
  },
  plugins: [
    {
      name: "outputMap",
      setup: (build) =>
        build.onEnd((result) => {
          const ob = Object.keys(result?.metafile?.outputs || {}).reduce((acc, file) => {
            const { entryPoint } = result.metafile.outputs[file]

            if (entryPoint) {
              const entryPath = entryPoint.substring(entryPoint.indexOf(outbase) - 1)
              const outPath = `${publicPath}${relativePath(outdir, file)}`
              acc[entryPath] = outPath
            }

            return acc
          }, {})

          result.outputMap = ob
        }),
    },
    {
      name: "writeAssetsEx",
      setup: (build) =>
        build.onEnd(
          (result) =>
            new Promise((resolve, reject) => {
              const metaContents = `# Generated by build.js, do not edit.

defmodule Nextcast.Assets do
  def output_map do
    %{
      ${Object.entries(result.outputMap).reduce((acc, [entryPath, outPath], ix, arr) => {
        const delimiter = arr.length - 1 === ix ? "" : ",\n"
        return `${acc}"${entryPath}" => "${outPath}"${delimiter}`
      }, "")}
    }
  end
end
`

              const manifestPath = resolvePath("lib", "_assets.ex")
              writeFile(manifestPath, metaContents, (err) => {
                if (err) return reject(err)
                console.info(`[build.js] Wrote ${manifestPath}`)
                resolve()
              })
            }),
        ),
    },
  ],
})

if (!isProduction) {
  await context.watch()
  console.info("[build.js] Watching...")
} else {
  await context.rebuild()
  console.info("[build.js] Done!")
  await context.dispose()
}
